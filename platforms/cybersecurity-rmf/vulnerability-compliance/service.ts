import { CVEAnalysis, CVE, VulnerabilityScan, VulnerabilityFinding, VulnerabilityMetrics } from './types'
import { createLogger } from '../../shared/logger'
import { NotFoundError } from '../../shared/errors'
import { prisma } from '../../shared/db'

const logger = createLogger('vulnerability-compliance')

export class VulnerabilityComplianceService {
  async analyzeCVE(data: Omit<CVEAnalysis, 'id' | 'status' | 'cves' | 'riskLevel' | 'recommendation' | 'createdAt'>): Promise<CVEAnalysis> {
    logger.info('Analyzing CVE for software', { softwareName: data.softwareName })

    // In production, query NVD/CVE databases
    const mockCVEs: CVE[] = [
      {
        id: 'CVE-2024-1234',
        title: 'Remote Code Execution Vulnerability',
        description: 'A vulnerability allows remote code execution',
        severity: 'high',
        cvssScore: 7.5,
        publishedDate: '2024-01-01',
        affectedVersions: [data.version],
        remediation: 'Update to version 2.0.1 or later',
        status: 'new',
      },
    ]

    const riskLevel = this.calculateRiskLevel(mockCVEs)
    const recommendation = this.getRecommendation(mockCVEs, riskLevel)

    const analysis = await prisma.cVEAnalysis.create({
      data: {
        softwareName: data.softwareName,
        version: data.version,
        status: 'completed',
        riskLevel,
        recommendation,
        cves: JSON.stringify(mockCVEs),
        completedAt: new Date(),
      },
    })

    return {
      id: analysis.id,
      softwareName: analysis.softwareName,
      version: analysis.version,
      status: analysis.status as any,
      cves: analysis.cves ? JSON.parse(analysis.cves) : [],
      riskLevel: analysis.riskLevel as any,
      recommendation: analysis.recommendation as 'approve' | 'approve-with-conditions' | 'reject' | 'requires-review',
      createdAt: analysis.createdAt.toISOString(),
      completedAt: analysis.completedAt?.toISOString(),
    }
  }

  async getCVEAnalysis(id: string): Promise<CVEAnalysis> {
    const analysis = await prisma.cVEAnalysis.findUnique({
      where: { id },
    })

    if (!analysis) {
      throw new NotFoundError('CVE Analysis', id)
    }

    return {
      id: analysis.id,
      softwareName: analysis.softwareName,
      version: analysis.version,
      status: analysis.status as any,
      cves: analysis.cves ? JSON.parse(analysis.cves) : [],
      riskLevel: analysis.riskLevel as any,
      recommendation: analysis.recommendation as 'approve' | 'approve-with-conditions' | 'reject' | 'requires-review',
      createdAt: analysis.createdAt.toISOString(),
      completedAt: analysis.completedAt?.toISOString(),
    }
  }

  async createScan(systemId: string, scanType: VulnerabilityScan['scanType']): Promise<VulnerabilityScan> {
    logger.info('Creating vulnerability scan', { systemId, scanType })

    const scan: VulnerabilityScan = {
      id: crypto.randomUUID(),
      systemId,
      scanType,
      status: 'pending',
      findings: [],
      startedAt: new Date().toISOString(),
    }

    const dbScan = await prisma.vulnerabilityScan.create({
      data: {
        systemId,
        scanType,
        status: 'pending',
      },
    })

    return {
      id: dbScan.id,
      systemId: dbScan.systemId,
      scanType: dbScan.scanType as any,
      status: dbScan.status as any,
      findings: [],
      startedAt: dbScan.startedAt.toISOString(),
      completedAt: dbScan.completedAt?.toISOString(),
    }
  }

  async runScan(scanId: string): Promise<VulnerabilityScan> {
    const scan = await this.getScan(scanId)
    
    logger.info('Running vulnerability scan', { scanId })

    await prisma.vulnerabilityScan.update({
      where: { id: scanId },
      data: { status: 'running' },
    })

    // In production, integrate with HBSS/EVSS/STIG scanners
    const findings: VulnerabilityFinding[] = [
      {
        id: crypto.randomUUID(),
        title: 'Missing Security Patch',
        severity: 'high',
        description: 'System is missing critical security patch KB123456',
        remediation: 'Install security patch KB123456',
        status: 'open',
        dueDate: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000).toISOString(),
      },
      {
        id: crypto.randomUUID(),
        title: 'Weak Password Policy',
        severity: 'medium',
        description: 'Password policy does not meet STIG requirements',
        remediation: 'Update password policy to enforce complexity',
        status: 'open',
        dueDate: new Date(Date.now() + 14 * 24 * 60 * 60 * 1000).toISOString(),
      },
    ]

    // Save findings to database
    await prisma.vulnerabilityFinding.createMany({
      data: findings.map(f => ({
        scanId,
        cveId: null,
        title: f.title,
        severity: f.severity,
        status: f.status,
        remediation: f.remediation || null,
      })),
    })

    const updated = await prisma.vulnerabilityScan.update({
      where: { id: scanId },
      data: {
        status: 'completed',
        completedAt: new Date(),
      },
    })

    return {
      id: updated.id,
      systemId: updated.systemId,
      scanType: updated.scanType as any,
      status: updated.status as any,
      findings,
      startedAt: updated.startedAt.toISOString(),
      completedAt: updated.completedAt?.toISOString(),
    }
  }

  async getScan(scanId: string): Promise<VulnerabilityScan> {
    const scan = await prisma.vulnerabilityScan.findUnique({
      where: { id: scanId },
    })

    if (!scan) {
      throw new NotFoundError('Vulnerability Scan', scanId)
    }

    const findings = await prisma.vulnerabilityFinding.findMany({
      where: { scanId },
    })

    return {
      id: scan.id,
      systemId: scan.systemId,
      scanType: scan.scanType as any,
      status: scan.status as any,
      findings: findings.map(f => ({
        id: f.id,
        title: f.title,
        severity: f.severity as any,
        description: '', // Would come from CVE analysis
        remediation: f.remediation || '',
        status: f.status as any,
        dueDate: undefined, // Would calculate from severity
      })),
      startedAt: scan.startedAt.toISOString(),
      completedAt: scan.completedAt?.toISOString(),
    }
  }

  async mitigateFinding(scanId: string, findingId: string, mitigation: string): Promise<VulnerabilityFinding> {
    const finding = await prisma.vulnerabilityFinding.findUnique({
      where: { id: findingId },
    })

    if (!finding || finding.scanId !== scanId) {
      throw new NotFoundError('Vulnerability Finding', findingId)
    }

    const updated = await prisma.vulnerabilityFinding.update({
      where: { id: findingId },
      data: {
        status: 'mitigated',
        remediation: mitigation,
      },
    })

    logger.info('Finding mitigated', { scanId, findingId })
    
    return {
      id: updated.id,
      title: updated.title,
      severity: updated.severity as any,
      description: '',
      remediation: updated.remediation || '',
      status: updated.status as any,
      dueDate: undefined,
    }
  }

  async getMetrics(): Promise<VulnerabilityMetrics> {
    const allScans = await prisma.vulnerabilityScan.findMany()
    const dbFindings = await prisma.vulnerabilityFinding.findMany()
    const allFindings = dbFindings.map(f => ({
      id: f.id,
      title: f.title,
      severity: f.severity as any,
      description: '',
      remediation: f.remediation || undefined,
      status: f.status as any,
      dueDate: undefined,
    }))
    
    return {
      totalScans: allScans.length,
      activeFindings: allFindings.filter(f => f.status === 'open').length,
      criticalFindings: allFindings.filter(f => f.severity === 'critical').length,
      averageRemediationTime: 5.2, // days - would calculate from historical data
      bySeverity: this.groupBy(allFindings, 'severity'),
      byStatus: this.groupBy(allFindings, 'status'),
    }
  }

  private calculateRiskLevel(cves: CVE[]): CVEAnalysis['riskLevel'] {
    if (cves.some(c => c.severity === 'critical')) return 'critical'
    if (cves.some(c => c.severity === 'high')) return 'high'
    if (cves.some(c => c.severity === 'medium')) return 'medium'
    return 'low'
  }

  private getRecommendation(cves: CVE[], riskLevel: CVEAnalysis['riskLevel']): CVEAnalysis['recommendation'] {
    if (riskLevel === 'critical') return 'reject'
    if (riskLevel === 'high') return 'requires-review'
    if (riskLevel === 'medium') return 'approve-with-conditions'
    return 'approve'
  }

  private groupBy<T>(items: T[], key: keyof T): Record<string, number> {
    return items.reduce((acc, item) => {
      const value = String(item[key] || 'unknown')
      acc[value] = (acc[value] || 0) + 1
      return acc
    }, {} as Record<string, number>)
  }
}

export const vulnerabilityComplianceService = new VulnerabilityComplianceService()

