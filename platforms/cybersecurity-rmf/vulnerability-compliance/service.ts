import { CVEAnalysis, CVE, VulnerabilityScan, VulnerabilityFinding, VulnerabilityMetrics } from './types'
import { createLogger } from '../../shared/logger'
import { NotFoundError } from '../../shared/errors'

const logger = createLogger('vulnerability-compliance')

export class VulnerabilityComplianceService {
  private cveAnalyses: Map<string, CVEAnalysis> = new Map()
  private scans: Map<string, VulnerabilityScan> = new Map()

  async analyzeCVE(data: Omit<CVEAnalysis, 'id' | 'status' | 'cves' | 'riskLevel' | 'recommendation' | 'createdAt'>): Promise<CVEAnalysis> {
    logger.info('Analyzing CVE for software', { softwareName: data.softwareName })

    // In production, query NVD/CVE databases
    const mockCVEs: CVE[] = [
      {
        id: 'CVE-2024-1234',
        title: 'Remote Code Execution Vulnerability',
        description: 'A vulnerability allows remote code execution',
        severity: 'high',
        cvssScore: 7.5,
        publishedDate: '2024-01-01',
        affectedVersions: [data.version],
        remediation: 'Update to version 2.0.1 or later',
        status: 'new',
      },
    ]

    const riskLevel = this.calculateRiskLevel(mockCVEs)
    const recommendation = this.getRecommendation(mockCVEs, riskLevel)

    const analysis: CVEAnalysis = {
      ...data,
      id: crypto.randomUUID(),
      status: 'completed',
      cves: mockCVEs,
      riskLevel,
      recommendation,
      createdAt: new Date().toISOString(),
      completedAt: new Date().toISOString(),
    }

    this.cveAnalyses.set(analysis.id, analysis)
    return analysis
  }

  async getCVEAnalysis(id: string): Promise<CVEAnalysis> {
    const analysis = this.cveAnalyses.get(id)
    if (!analysis) {
      throw new NotFoundError('CVE Analysis', id)
    }
    return analysis
  }

  async createScan(systemId: string, scanType: VulnerabilityScan['scanType']): Promise<VulnerabilityScan> {
    logger.info('Creating vulnerability scan', { systemId, scanType })

    const scan: VulnerabilityScan = {
      id: crypto.randomUUID(),
      systemId,
      scanType,
      status: 'pending',
      findings: [],
      startedAt: new Date().toISOString(),
    }

    this.scans.set(scan.id, scan)
    return scan
  }

  async runScan(scanId: string): Promise<VulnerabilityScan> {
    const scan = await this.getScan(scanId)
    
    logger.info('Running vulnerability scan', { scanId })

    scan.status = 'running'
    this.scans.set(scanId, scan)

    // In production, integrate with HBSS/EVSS/STIG scanners
    const findings: VulnerabilityFinding[] = [
      {
        id: crypto.randomUUID(),
        title: 'Missing Security Patch',
        severity: 'high',
        description: 'System is missing critical security patch KB123456',
        remediation: 'Install security patch KB123456',
        status: 'open',
        dueDate: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000).toISOString(),
      },
      {
        id: crypto.randomUUID(),
        title: 'Weak Password Policy',
        severity: 'medium',
        description: 'Password policy does not meet STIG requirements',
        remediation: 'Update password policy to enforce complexity',
        status: 'open',
        dueDate: new Date(Date.now() + 14 * 24 * 60 * 60 * 1000).toISOString(),
      },
    ]

    scan.findings = findings
    scan.status = 'completed'
    scan.completedAt = new Date().toISOString()
    this.scans.set(scanId, scan)

    return scan
  }

  async getScan(scanId: string): Promise<VulnerabilityScan> {
    const scan = this.scans.get(scanId)
    if (!scan) {
      throw new NotFoundError('Vulnerability Scan', scanId)
    }
    return scan
  }

  async mitigateFinding(scanId: string, findingId: string, mitigation: string): Promise<VulnerabilityFinding> {
    const scan = await this.getScan(scanId)
    const finding = scan.findings.find(f => f.id === findingId)
    
    if (!finding) {
      throw new NotFoundError('Vulnerability Finding', findingId)
    }

    finding.status = 'mitigated'
    this.scans.set(scanId, scan)

    logger.info('Finding mitigated', { scanId, findingId })
    return finding
  }

  async getMetrics(): Promise<VulnerabilityMetrics> {
    const allScans = Array.from(this.scans.values())
    const allFindings = allScans.flatMap(s => s.findings)
    
    return {
      totalScans: allScans.length,
      activeFindings: allFindings.filter(f => f.status === 'open').length,
      criticalFindings: allFindings.filter(f => f.severity === 'critical').length,
      averageRemediationTime: 5.2, // days - would calculate from historical data
      bySeverity: this.groupBy(allFindings, 'severity'),
      byStatus: this.groupBy(allFindings, 'status'),
    }
  }

  private calculateRiskLevel(cves: CVE[]): CVEAnalysis['riskLevel'] {
    if (cves.some(c => c.severity === 'critical')) return 'critical'
    if (cves.some(c => c.severity === 'high')) return 'high'
    if (cves.some(c => c.severity === 'medium')) return 'medium'
    return 'low'
  }

  private getRecommendation(cves: CVE[], riskLevel: CVEAnalysis['riskLevel']): CVEAnalysis['recommendation'] {
    if (riskLevel === 'critical') return 'reject'
    if (riskLevel === 'high') return 'requires-review'
    if (riskLevel === 'medium') return 'approve-with-conditions'
    return 'approve'
  }

  private groupBy<T>(items: T[], key: keyof T): Record<string, number> {
    return items.reduce((acc, item) => {
      const value = String(item[key] || 'unknown')
      acc[value] = (acc[value] || 0) + 1
      return acc
    }, {} as Record<string, number>)
  }
}

export const vulnerabilityComplianceService = new VulnerabilityComplianceService()

